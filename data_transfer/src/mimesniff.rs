use byteorder::{BigEndian, ReadBytesExt};
use utf16_lit::utf16;

pub fn detect_content_type(content: &[u8]) -> String {
    let mut first_non_ws = 0;
    while first_non_ws < 512 && is_ws(content[first_non_ws] as u16) {
        first_non_ws += 1;
    }
    if &content[0..JPEG.len()] == &JPEG {
        return "image/jpeg".to_string();
    }
    if &content[0..PNG.len()] == &PNG {
        return "image/png".to_string();
    }
    if &content[0..GIF1.len()] == GIF1 {
        return "image/gif".to_string();
    }
    if &content[0..GIF2.len()] == GIF2 {
        return "image/gif".to_string();
    }
    if match_mp4(content) {
        return "video/mp4".to_string();
    }
    String::from("")
}

fn match_mp4(buf: &[u8]) -> bool {
    if buf.len() < 12 {
        return false;
    }
    let mut temp = buf.clone();
    if let Ok(val) = temp.read_u32::<BigEndian>() {
        let box_size = val as usize;
        if box_size % 4 != 0 || buf.len() < box_size {
            return false;
        }
        if &buf[4..8] != FTYP {
            return false;
        }
        let mut st = 8;
        while st < box_size {
            if st == 12 {
                st += 4;
                continue;
            }
            if &buf[st..st + 3] == MP4 {
                return true;
            }
            st += 4;
        }
    }
    false
}

const JPEG: [u8; 3] = [0xff, 0xd8, 0xff];
const PNG: [u8; 8] = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];
const GIF1: &'static [u8] = "GIF87a".as_bytes();
const GIF2: &'static [u8] = "GIF89a".as_bytes();
const MP4: &'static [u8] = "mp4".as_bytes();
const FTYP: &'static [u8] = "ftyp".as_bytes();

const TAB: u16 = utf16!("\t")[0];
const NL: u16 = utf16!("\n")[0];
const PB: u16 = utf16!(",0x0c")[0];
const RET: u16 = utf16!("\r")[0];
const SP: u16 = utf16!(" ")[0];

fn is_ws(b: u16) -> bool {
    match b {
        TAB | NL | PB | RET | SP => true,
        _ => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const JPEG_FILE: &'static [u8] = &[
        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00,
        0x48, 0x00, 0x48, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x02, 0x02,
        0x02, 0x03, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x06, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x08, 0x06, 0x06, 0x05, 0x06, 0x09, 0x08, 0x0a, 0x0a, 0x09, 0x08, 0x09, 0x09, 0x0a,
        0x0c, 0x0f, 0x0c, 0x0a, 0x0b, 0x0e, 0x0b, 0x09, 0x09, 0x0d, 0x11, 0x0d, 0x0e, 0x0f, 0x10,
        0x10, 0x11, 0x10, 0x0a, 0x0c, 0x12, 0x13, 0x12, 0x10, 0x13, 0x0f, 0x10, 0x10, 0x10, 0xff,
        0xc9, 0x00, 0x0b, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xff, 0xcc, 0x00,
        0x06, 0x00, 0x10, 0x10, 0x05, 0xff, 0xda, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3f, 0x00,
        0xd2, 0xcf, 0x20, 0xff, 0xd9,
    ];

    const PNG_FILE: &'static [u8] = &[
        0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44,
        0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x25,
        0xdb, 0x56, 0xca, 0x00, 0x00, 0x00, 0x03, 0x50, 0x4c, 0x54, 0x45, 0xff, 0x4d, 0x00, 0x5c,
        0x35, 0x38, 0x7f, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0xcc, 0xd2, 0x34, 0x56,
        0xfd, 0x00, 0x00, 0x00, 0x0a, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x62, 0x00, 0x00,
        0x00, 0x06, 0x00, 0x03, 0x36, 0x37, 0x7c, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e,
        0x44, 0xae, 0x42, 0x60, 0x82,
    ];

    const GIF_FILE: &'static [u8] = &[
        0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x0A, 0x00, 0x0A, 0x00, 0x91, 0x00, 0x00, 0xff, 0xff,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x21, 0xF9, 0x04, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x0a, 0x00, 0x00, 0x02, 0x16,
        0x8c, 0x2d, 0x99, 0x87, 0x2a, 0x1c, 0xdc, 0x33, 0xa0, 0x02, 0x75, 0xec, 0x95, 0xfa, 0xa8,
        0xde, 0x60, 0x8c, 0x04, 0x91, 0x4c, 0x01, 0x00, 0x3b,
    ];

    const MP4_FILE: &'static [u8] = &[
        0x00, 0x00, 0x00, 0x1c, 0x66, 0x74, 0x79, 0x70, 0x6d, 0x70, 0x34, 0x32, 0x00, 0x00, 0x00,
        0x00, 0x6d, 0x70, 0x34, 0x32, 0x69, 0x73, 0x6f, 0x6d, 0x61, 0x76, 0x63, 0x31, 0x00, 0x00,
        0x00, 0x84, 0x66, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn sniff_jpg() {
        assert_eq!(detect_content_type(JPEG_FILE), "image/jpeg".to_string());
    }

    #[test]
    fn sniff_png() {
        assert_eq!(detect_content_type(PNG_FILE), "image/png".to_string());
    }

    #[test]
    fn sniff_gif() {
        assert_eq!(detect_content_type(GIF_FILE), "image/gif".to_string());
    }

    #[test]
    fn sniff_mp4() {
        assert_eq!(detect_content_type(MP4_FILE), "video/mp4".to_string());
    }
}
